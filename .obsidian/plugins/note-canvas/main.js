/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  default: () => CanvasPlugin
});
module.exports = __toCommonJS(main_exports);

// src/convertor.ts
var import_obsidian = require("obsidian");

// src/utils.ts
var WIDTH = 200;
var HEIGHT = 60;
var X_GAP = WIDTH / 2;
function convertToCache(cache, data, setting = DEFAULT_SETTINGS, title) {
  const { headings = [], sections = [] } = cache;
  let yAxis = 0;
  let head = 0;
  const first = {
    id: "1",
    pid: "",
    text: title,
    level: 1,
    layer: 1,
    x: 1,
    y: 0
  };
  const levels = [1, ...new Array(10).fill(0)];
  const layers = [1, ...new Array(10).fill(0)];
  let last_level = 0;
  let last_s = 0;
  const items = sections.map(({ type, position }) => {
    if (type === "heading") {
      const { level, heading } = headings[head];
      levels[level - 1] += 1;
      layers[level - 1] += 1;
      if (levels[level - 1] > 1 || last_s > 0) {
        yAxis += 1;
      }
      levels.fill(0, level);
      const id = levels.slice(0, level).join("-");
      const pid = levels.slice(0, level - 1).join("-");
      head += 1;
      last_level = level;
      last_s = 0;
      return {
        id,
        pid,
        text: heading,
        level,
        layer: layers[level - 1],
        x: level,
        y: yAxis
      };
    } else {
      const { start, end } = position;
      if (last_s > 0) {
        yAxis += 1;
      }
      last_s += 1;
      const pid = levels.slice(0, last_level).join("-");
      const id = `${pid}-s${last_s}`;
      const text = data.slice(start.offset, end.offset);
      layers[last_level] += 1;
      return {
        id,
        pid,
        text,
        x: last_level + 1,
        y: yAxis,
        layer: layers[last_level],
        level: last_level + 1
      };
    }
  });
  console.table(items);
  const edges = items.map(({ pid, id }) => ({
    id: `${pid}/${id}`,
    fromNode: pid,
    fromSide: "right",
    toNode: id,
    toSide: "left"
  }));
  const { width, height, layout, colGap, rowGap } = setting;
  const nodes = [first, ...items].map(
    ({ x, y, id, text, layer }) => ({
      id,
      text,
      type: "text",
      x: x * (width + colGap),
      y: layout == "compact" ? layer * (height + rowGap) : y * (HEIGHT + rowGap),
      height,
      width
    })
  );
  return { nodes, edges };
}

// src/convertor.ts
var Convertor = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async nodeToCanvas() {
    var _a, _b, _c, _d, _e, _f;
    const ws = this.app.workspace;
    const vault = this.app.vault;
    const view = ws.getActiveViewOfType(import_obsidian.MarkdownView);
    const data = (_b = view == null ? void 0 : view.data) != null ? _b : (_a = ws.activeEditor) == null ? void 0 : _a.data;
    const file = ws.getActiveFile();
    if (!file) {
      return;
    }
    const cache = this.app.metadataCache.getFileCache(file);
    const lists = (_c = cache == null ? void 0 : cache.listItems) == null ? void 0 : _c.map((item) => {
      const { start, end } = item.position;
      return {
        ...item,
        indent: start.col,
        text: data.slice(start.offset, end.offset)
      };
    });
    console.table(lists);
    const headings = [
      { heading: file.basename, level: 1 },
      ...(_d = cache == null ? void 0 : cache.headings) != null ? _d : []
    ];
    const jsonData = convertToCache(cache != null ? cache : {}, data, this.plugin.settings, file.basename);
    const adapter = vault.adapter;
    const output = `${(_f = (_e = file.parent) == null ? void 0 : _e.path) != null ? _f : ""}/${file.basename}.canvas`;
    if (await adapter.exists(output)) {
      await adapter.trashLocal(output);
    }
    await vault.create(output, JSON.stringify(jsonData, void 0, 2));
    const leaf = ws.getLeaf("tab");
    const outFile = vault.getFileByPath(output);
    if (outFile) {
      await leaf.openFile(outFile);
    }
  }
};

// src/main.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  width: 200,
  height: 60,
  colGap: 100,
  rowGap: 30,
  layout: "compact"
};
var CanvasPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "note-to-canvas",
      name: "Convert note to canvas",
      callback: async () => {
        const convertor = new Convertor(this.app, this);
        await convertor.nodeToCanvas();
      }
    });
    this.addSettingTab(new CanvasSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var CanvasSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Width").setDesc("Node width").addText(
      (text) => text.setPlaceholder("Enter your node width").setValue(this.plugin.settings.width.toString()).onChange(async (value) => {
        this.plugin.settings.width = parseFloat(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Height").setDesc("Node height").addText(
      (text) => text.setPlaceholder("Enter your node height").setValue(this.plugin.settings.height.toString()).onChange(async (value) => {
        this.plugin.settings.height = parseFloat(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Column gap").addText(
      (text) => text.setValue(this.plugin.settings.colGap.toString()).onChange(async (value) => {
        this.plugin.settings.colGap = parseFloat(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Row gap").addText(
      (text) => text.setValue(this.plugin.settings.rowGap.toString()).onChange(async (value) => {
        this.plugin.settings.rowGap = parseFloat(value);
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Layout ").setDesc("Layout style").addDropdown(
      (dropdown) => dropdown.addOptions(
        Object.fromEntries(["compact", "loose"].map((type) => [type, type]))
      ).setValue(this.plugin.settings.layout).onChange(async (value) => {
        this.plugin.settings.layout = value;
        this.plugin.saveSettings();
      })
    );
  }
};
